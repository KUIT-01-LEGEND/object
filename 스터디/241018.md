# 오브젝트 1차 스터디
> 2024.10.18(금) 14시~17시
> 도서관 인큐스페이스 1호실
> 강연주, 이영선, 이현희, 정소민
> 오브젝트 1~3장 + 코드에 적용(덧셈 계산기)

## 영선 1장 정리

- 캡슐화는 결합도와 응집도를 개선하기 위한 수단일 뿐이다.

  중요한 건 결합도, 응집도!

- 리팩토링을 하면 결합도와 응집도가 함께 개선되지만, 어느 순간부터는 둘 사이의 트레이드 오프 관계가 발생한다.
- 우리는! 트레이드 오프 관계 증 결합도를 낮추는 것이 더 좋다고 생각한다!
- bag과 audience를 합치는게 더 좋은 설계 아닐까? 아마 실세계의 의인화를 위해서 객체를 최대한 쪼갠거같음

## 소민 2장 정리

- 협력이 객체를 낳고, 객체가 클래스를 낳는다.
- 도메인 : 문제를 해결하고자 하는 분야. 협력을 구성하는 개념

프로그래머는 두 종류로 나뉜다

- 클라이언트 프로그래머 : api 사용하는 사람듬

  → 내부 구현을 몰라도 쓸 수 있어서 좋음

- 클래스 작성자 : api 작성자

  → 내부 구현 맘대로 바꿀 수 있어서 좋음

  api 사용이 편한 이유는 캡슐화가 잘 되어 있어서 (인터페이스와 구현 분리)


Money 객체는 Integer만 가지고 있음

= 일급 컬렉션

**: 도메인의 의미나 규칙, 제약 등을 풍부하게 표현하기 위해서**

코드의 의존성을 따르는게 절차지향이고, 실행 시점의 의존성을 따르는게 객체지향이다. (객체지향은 의존성이 실행 시점에 결정된다. by 동적 바인딩, 정적 바인딩)

- **동적 바인딩, 정적 바인딩 추가로 알아보기!!!**

https://todayscoding.tistory.com/16

디폴트 메서드를 사용하면 인터페이스의 구현 공유 가능

추상화의 장점 : 요구사항을 높은 수준에서 서술 가능, 설계가 유연해짐

추상화해서 설명 → 더 단순한 설명 가능

디자인패턴, 프레임워크 모두 추상화를 이용한 상위 정책이다!

할인 정책이 없는 경우 → if null이면 으로 처리하면 추상화의 일관성이 깨져서 올바르지 않음! 그래서 NoneDiscountPolicy 클래스를 구현해야 한다.

인터페이스 추가 → 유연한만큼 더 복잡하다.. 넌 어떻게 할래?

상속은 설계를 유연하게 만들지 못하는 이유 :

- **결론 : 상속보다 합성이 좋다.**
    - Movie에서 DiscountPolicy를 변수로 갖고 있으면 Policy를 바꾸고 싶을 때 그냥 주입할 때 다른 객체로 넣어주면 됨
    - 근데 Movie를 상속해서 PercentMovie, AmountMovie, NoneDiscountMovie를 만들면 Movie 구현체를 바꾸고 싶을 때에 이전 구현체에서 새로운 구현체로 값들을 다 받아와서 변경해야함 → 변경에 유연하지 못함

## 현희 3장 정리

책임 협력 역할이다.

- 책임 = 행동 = 각 객체가 협력 속에서 실행하는 로직
- 역할 : 책임의 집합 (배역 = 역할, 배우 = 객체,

  하나의 객체가 여러 역할을 할 수 있고,

  한 역할을 여러 객체가 수행할 수 있다.)

- 협력은 메시지를 통해 일어남.

- Movie : 상영, x → 영화의 가격 계산 (객체의 역할은 구현하고자 하는 시스템에 적합하게 할당해야 한다.)

객체 목록(도메인 모델) → 메시지 만들기 → 객체에게 책임 할당하기