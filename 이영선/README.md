# 오브젝트 정리

## 1️⃣ 객체, 설계
#### [예제 코드 : 초대권 유무에 따라 티켓을 다르게 발행하는 시스템](./code/src/main/java/theater)
> 객체지향 프로그램을 설계하고 유지보수 하기 위해서 실무, 즉 코드 자체에 초점을 맞출 것이다.
> 직접 만들어 보며 배우기!

- 애플리케이션의 핵심 클래스
  ![](image/13p.png)
  ![](image/13p_class_diagram.png)
    - 이 코드의 문제점
- Theater가 Audience의 Bag와 TicketSeller의 TicketOffice에 직접 접근한다. 

  = Theater가 Audience와 TicketSeller에 결합된다.

  = 객체가 자율적이지 않고 수동적이다.
  
→ Audience와 TicketSeller가 스스로 자신의 데이터를 관리하도록 한다. 자율적인 존재로 만들자.

- 🌟 **캡슐화** : 외부에는 메서드라는 API (인터페이스)만 제공하고, 내부의 구현은 숨기자.
  - TicketSeller는 sellTo() 메서드만 제공
  - Audience는 buy() 메서드만 제공

  장점
  - TicketSeller.sellTo(), Audience.buy()의 내부 구현을 변경해도 Theater에는 아무 지장이 없다.
  - TicketSeller, Audience 객체의 자율성을 높였다. 유연한 설계 & 객체의 응집도 향상
  > 응집도가 높다 
  > 
  > = 밀접하게 연관된 작업만 수행하고 연관성 없는 작업은 다른 객체에게 위임한다.
  >              
  > = 자신의 데이터를 스스로 책임진다. (처리한다.)

<aside>
💡 객체지향적으로 좋은 설계
  
- 높은 응집도

- 낮은 결합도

이를 위해선 불필요한 의존성은 제거하여 최소한의 의존성만 남겨야 한다.
</aside>


![](image/24p_class_diagram.png)

- Bag의 hold() 메서드와 TicketOffice의 sellTicketTo() 메서드를 구현함으로써 더 응집도 높고 자율적인 객체들로 만들었다. 
  ![](image/32p_class_diagram.png)
  
  💥근데 그 결과, Audience에 대한 의존성이 더 추가되어 결합도가 높아졌다.
    훌륭한 설계는 적절한 트레이드 오프의 결과물이다.

- 결론 : 휼륭한 객체지향 설계란
  - 협력하는 객체 사이의 의존성을 적절히 관리하는 설계
    - 최소한의 의존성만 남기다보면, 어느 순간 높은 응집도-높은 결합도 🆚 낮은 응집도-낮은 결합도 사이에서 적절한 균형을 찾아야 한다.
    - 적절한 의존성 = 적절한 객체에게 적절한 책임을 할당한 설계
  - 모든 객체들이 자율적으로 행동하는 설계 (객체들을 생물로 보기)
    - 이러한 측면에서 우리가 생각했던 대로 객체가 행동하기 때문에 보다 이해하기 쉬운 코드가 된다.
  - 변경에 유연하게 대응할 수 있는 설계
    - 구현은 숨기고 인터페이스만 제공하기 때문에 변경에 용이하다.

## 2️⃣ 객체지향 프로그래밍
#### [예제 코드 : 영화 예매 시스템](./code/src/main/java/reservation)

용어 정리

- 영화 (Movie) = 영화 정보
- 상영 (Screening) = 실제 관객들이 영화를 관람하는 사건. 실제 예매 대상
- 할인 조건 = 할인 여부 결정 (할인 O/X)
- 할인 정책 = 할인 요금 결정 (얼마 할인)

  1개의 Movie는 하나의 할인 정책만 갖는다.

  1개의 Screening은 하나의 할인 조건만 갖는다.

![](image/54p_class_diagram.png)

- **객체지향 설계 순서**
  1. 클래스(x) 객체(o) 에 초점을 맞추자!!!

     어떤 객체가 필요한지 고민하자.

     추상적인 것(클래스)이 아니라 구체적인 것(객체)를 먼저 결정해야 한다.

  2. 객체를 독립적인 존재가 아니라, 협력하는 공동체의 일원으로 봐야 한다.

     객체들 간의 협력을 고민하자.

  3. 객체들의 윤곽이 잡히면, 객체들의 공통된 특성, 상태끼리 분류하여 추상화하자! = 클래스 구현


- 캡슐화 : 데이터와 기능을 묶어 하나의 객체에 넣음

  캡슐화 + 접근 제어자 → public 메서드를 통해서만 내부 상태를 변경할 수 있음 (내부/외부 구분)

  → 객체의 자율성 보장, 구현의 자유 보장

  외부에는 인터페이스만 제공하고 내부 구현은 감춤으로써 변경에 대한 파급효과를 제어한다.


- Money라는 객체를 만든 이유

  long 타입 데이터를 쓸 수도 있지만, 이것은 금액과 관련되어 있다는 의미를 전달할 수 없다.

  Money 객체를 사용하면 도메인의 의미를 좀 더 명시적이고 풍부하게 표현할 수 있다. (설계의 명확성⬆️, 유연성⬆️)


- 생성자를 사용하여 초기화에 필요한 정보들을 강제하면, 올바른 객체 생성을 보장할 수 있다.


- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다.
  - 장점 : 재사용성⬆️, 확장 가능성⬆️, 유연한 설계
  - 단점 : 가독성⬇️, 이해하기 어려움

  ⇒ 트레이드 오프



- **추상화**의 장점
  - 요구사항을 더 높은 수준에서 서술할 수 있다.

    더 쉽고 간단하게 표현할 수 있다.

  - 설계가 더 유연해진다.

    새로운 기능을 쉽게 추가하고 확장할 수 있다.

    OCP : 변경에 닫혀있고, 확장에 열려있다.

    DIP : 구체적인 것에 의존하지 않고, 추상적인 것에 의존한다.


### 다형성

메서드 호출 ≠ 메세지 전송

ex. A 객체가 B객체의 b.run() 호출
- B 객체는 외부 객체에게 run() 이라는 인터페이스를 제공한다.
- A 객체를 포함함 외부 객체들은 run() ~~메서드를 호출한다.~~  메시지를 전송한다.

  A 객체는 누가 이 요청을 처리하는 지는 관심이 없다. 오직 ‘내가 보낸 메시지를 처리할 수 있는가’ 에만 관심이 있다. 그래서 B가 요청을 처리하든, B의 자식이 요청을 처리하든 상관X

  그래서 부모 클래스 대신 자식 클래스를 사용하는 것이 가능하다.

  = 외부 객체는 부모 클래스와 자식 클래스를 동일한 타입으로 간주한다.

  = 업캐스팅 (자식이 부모 자리를 대신하는 것)


> **다형성** : 똑같은 메시지를 보냈을 때, 객체의 타입에 따라 다르게 응답할 수 있는 능력
>
- 똑같은 메시지를 보냈지만, 어떤 메서드가 실행될 지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

  ex. 똑같은 `getDiscountAmount()` 메서드를 실행했지만, `Movie`가 어떤 `DiscountPolicy` 구현체를 가지고 있는가에 따라 다른 금액이 반환된다.

- 모든 다형성에서 실행될 메서드는 컴파일 시점이 아닌 실행 시점에 결정된다. (동적 바인딩, 지연 바인딩)


- **다형성 구현 방법**

  상속과 합성의 공통점 = 코드를 재사용하기 위한 방법

  - **상속**
    - 자식 클래스는 부모 클래스가 제공하는 모든 인터페이스를 물려받을 수 있다.
    - 단점
      - 캡슐화를 위반한다. (부모의 구현이 자식에게 노출된다.)
      - 설계를 유연하지 못하게 만든다. (컴파일 시점에 상속 관계가 결정되어 실행 시점에 바꿀 수 없다)
  - **합성**
    - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방식이다.

      → 구현을 캡슐화할 수 있다.

      → 메시지를 통해 느슨하게 결합된다.


    ⇒ 결론: 코드를 재사용하기 위해서는 합성을 사용하는 게 좋음.
    
    다형성을 위해서는 둘을 조합해서 사용해야 한다.


### 추상 클래스 🆚 인터페이스 트레이드오프

- DiscountPolicy를 추상클래스로 구현하여 상속을 사용한 경우

  ![](image/68p_abstract_class.png)

- DiscountPolicy를 인터페이스로 구현하여 구현을 사용한 경우

  ![](image/69p_interface.png)

→ 이상적으로는 인터페이스를 사용한 설계가 더 좋아야 하지만, 실제로는 더 복잡하다.

    ❗구현과 관련된 모든 것들은 트레이드오프의 대상이 될 수 있다.
    
    따라서 내가 작성하는 모든 코드에는 아무리 사소한 결정이라도 합당한 이유가 있어야 한다.

    항상 고민하고 트레이드오프 하자❗

