# 실무는 이론에 앞선다
이론은 실무를 가지고 만든 귀납적 결과물

특히 소프트웨어 설계, 유지보수 분야에서는 실무가 이론보다 다섯 수는 앞서있음.

따라서, 설계와 유지보수에 대해서 논할 때는 이론보다는 실무(=코드)를 가지고 논하는 게 좋음

# 작은 소극장 예제
막간 자바 문법 - ellipsis => 인자가 "Ticket ... tickets"면, Ticket[] 타입

## 소프트웨어 모듈의 3가지 목적
1. 실행 중 제대로 동작하는 것
2. 변경에 용이한 것
3. 의사소통에 용이한 것

위의 소극장 예제는 1번만 달성함

2번 => Audience나 TicketSeller 변경 시 Theater 수정 필요. Bag이나 TicketOffice 수정 시에도 Teather 수정 필요.
3번 => 직관과 위배됨. Theater가 Audience의 가방을 맘대로 열어보고 돈을 차감함.

Theater가 모든 객체들에게 관여함 => Theater의 의존성이 과하다 = 결합도가 높다

# 개선하기
## 1차 개선
Theater가 모든 객체들에게 접근하고 관여하는 것이 문제 => 다른 객체들의 자율성을 보장해야 함.

Audience가 알아서 Bag을 처리하도록 하고, TicketSeller가 알아서 TicketOffice와 Ticket을 처리하도록 함.

자율적인 객체만 보장해주면 응집도는 올라가고, 결합도는 낮아짐.

## 절차지향 vs 객체지향
프로세스와 데이터를 어디에 담냐에 대한 관점으로 비교 가능

절차지향에서 객체는 그냥 데이터를 담을 뿐. 프로세스는 하나의 객체가 통솔함.

객체지향은 객체가 알아서 자신의 데이터를 처리함. 즉, 객체가 데이터와 프로세스를 다 같이 가지고 있음.

## 2차 개선
Audience가 Bag의 자율성을 보장하도록 변경 + TicketSeller가 TicketOffice의 자율성을 보장하도록 변경

Audience가 Bag에게 자율성을 준 건 좋은데, TicketSeller가 TicketOffice에게 자율성을 주니 결합도가 증가함

TicketOffice가 Audience에 대한 의존성을 가짐.

trade off라 선택해야 함.

## 의인화
의사소통을 위해서는 코드가 직관적이어야 하긴 함.

그런데 스스로 짐을 빼고 넣는 가방같이 객체가 의인화 되는 것은 감당할 필요가 있음.

# 설계
무슨 고차원적인 일이 아니라, 코드를 어디에 위치시킬 지 결정하는 것.

따라서 코드가 없이는 논의가 불가능함.

## 좋은 설계
소프트웨어의 요구사항은 매번 변함 = 쉽게 변경할 수 있어야 함 = 쉽게 이해되어야 함

데이터와 프로세스를 합친 객체의 형태로 작성하면 이해하기 쉬워짐
1. 데이터와 프로세스를 객체로 모으기

그러나 객체로 모았다고 다 끝난 것은 아니고, 객체 간의 상호작용 즉, 의존성을 관리해야 함
2. 객체 간 의존성 관리

+ 어떻게 보면 1번은 응집도고 2번은 결합도인듯??