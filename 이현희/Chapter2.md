# 영화 예매 시스템 요구사항
영화 : 영화에 대한 기본정보를 의미

상영 : 실제로 관객들이 영화를 관람하는 사건을 의미<br>
=> 관객들은 영화가 아니라 상영을 위해 돈을 지불하는 것

특정 조건을 만족하면 할인 가능
1. 할인 조건 : 할인 여부 결정
   1. 순서 조건 : 입장 순번에 따라 할인 여부 결정 eg. 10번째 손님 할인
   2. 기간 조건 : 요일, 시작시간, 종료시간으로 구성. 그 기간에 포함되면 할인 대상
2. 할인 정책 : 할인 액수 결정
   1. 금액 할인 정책 : 특정 값 만큼 할인
   2. 비율 할인 정책 : 특정 비율 만큼 할인

영화 별로 0 또는 1개의 할인 정책 지정 가능<br>
할인 조건은 할인 정책이 있다면, 몇 개든 상관 없음(0개?)

할인 적용을 위해서는
1. 할인 조건을 만족하는가 확인
2. 할인 정책을 통한 요금 계산

사용자가 예매를 완료하면, 시스템은 예매 정보를 생성

# 협력, 객체, 클래스, 도메인
객체지향은 클래스가 아니고 객체를 지향

협력 속에 1. 어떤 객체가 필요하고 2. 그 객체들에게 어떤 책임을 할당할 것인지에 집중<br>
객체 식별 -> 타입 식별 -> 클래스 설계

## 도메인 구조 -> 클래스 구조
도메인 = 문제를 해결하기 위해 소프트웨어를 사용하는 분야

객체지향의 장점 : 도메인 분석 ~ 코드 구현까지 객체라는 추상화 기법을 동일하게 이용가능

## 클래스 생성
공용 인터페이스는 public으로, 구현은 private으로 => 객체의 자율성, 프로그래머의 자유 보장 가능
1. 객체의 자율성
   객체 = 상태 + 행동
   캡슐화 => 인터페이스와 구현의 분리
2. 프로그래머의 자유
   프로그래머를 2가지로 분리
   1. 클래스 작성자(=API 작성자)
   2. 클라이언트 프로그래머(=API 이용자)
   
   이때 인터페이스와 구현의 분리는 둘 모두에게 이롭다 

   설계라는 건 변경이 쉽도록 하는 것

## 협력 속의 객체 공동체
영화 예매 가격 계산을 Screening이 Movie에게 요청

협력 속에서, 객체는 자신이 할 수 없는 일을 요청하고 그걸 받은 객체는 응답함.

메시지와 메서드

Money라는 멤버 변수가 하나 뿐인 클래스 => 도메인의 의미를 풍부하게 표현<br>
특정 제약이나 규칙 반영 가능(like 일급 컬렉션)

## 할인 요금 계산을 위한 협력
Movie 클래스 내에서는 할인 정책에 따라 할인 가격을 계산하는 것을 요청함.

그런데 어떤 할인 정책을 사용할 지는 명시되어 있지 않음 => 상속을 통한 다형성 이용

할인 정책 클래스(DiscountPolicy)는 큰 흐름만 구성되어 있는 abstract class이고,<br>
구체적인 할인 가격 계산은 자식에게 맡기고 있음(Template Method 패턴)

# 기타 사항
## 생성자를 통한 객체의 상태 보장
도메인의 규약사항을 생성자로 표현 가능

Movie의 생성자 => DiscountPolicy 1개만을 인자로 받음
DiscountPolicy의 생성자 => DiscountCondition 여러 개를 인자로 받음

## 컴파일 시간 의존성과 런타임 의존성
어떤 클래스가 다른 클래스에 접근할 수 있는 경로가 있거나(=참조 변수?),<br>
해당 클래스의 메서드를 호출할 경우, 둘 사이에 의존성이 있다고 말함.

Movie 클래스의 경우, DiscountPolicy에 의존함.<br>
얘는 구체적인 구현이 아니고 추상적인 개념임

그런데 실제 생성자를 호출할 때 구체적인 구현체를 넣어줌

즉, 코드에서의 의존성 실제 실행 시의 의존성은 다를 수 있다.<br>
다른 말로, 컴파일 시간의 의존성과 런타임의 의존성을 다를 수 있다.

이것이 바로 유연성, 재사용성의 근원.

그러나 설계가 유연해질 수록, 코드를 이해하긴 어렵다.<br>
실제로는 누구와 의존하는 지 가봐야 아니까;;

## 의존성이 어떻게 바뀔 수 있는건데?
상속을 통해 다형성을 구현했기 때문

상속은 코드 재사용의 의미도 있지만, 인터페이스의 승계라는 의미도 있음.<br>
인터페이스란 객체가 이해할 수 있는 메시지의 모음이고, 타입의 근원이다.

자식 객체는 부모와 이해할 수 있는 인터페이스가 같거나 더 많기 때문에,<br>
자식 클래스는 부모 클래스와 같은 타입으로 불 수 있음.(=업캐스팅)

Movie 입장에서는 누가 대답하던 알바 아님. 그냥 이 메시지를 이해하고 응답할 대상이 필요할 뿐

다형성 = 하나의 메시지에 대해 다르게 대답할 수 있는 능력

컴파일 시간이 아닌 런타임에 "메시지에 대한 응답 메서드"를 결정함으로써 가능(=동적 바인딩)

다형성 구현을 위해서는 상속 뿐 아니라 인터페이스도 있음.<br>
인터페이스는 공유할 구현이 하나도 없을 때 쓰는 것

## 추상화와 유연성
추상화의 장점
1. 요구사항은 높은 수준에서 서술 가능(=인지 과부하 줄임)
2. 설계가 유연해짐

추상화를 이용해 요구사항을 기술한다는 것 = 애플리케이션의 협력흐름을 기술한다는 것<br>
이 협력 흐름을 재사용될 수 있다. 그 예시가 바로 디자인 패턴이나 프레임워크

추상화를 중심으로 설계하면, 유연하고 확장 가능해짐. 잘 변하는, 구체적인 것에 의존하지 않기 때문

협력 흐름을 추상화한다는 관점에서, 예외 상황을 만드는 것은 좋은 방식이 아님. 협력 흐름이 깨지는 상황이 생기는 거니까~

컨텍스트 독립성 <- 이게 먼 뜻임?

## NoneDiscountPolicy에서 추상클래스 방식 vs 인터페이스 방식
할인 정책이 존재할 때의 흐름과 없을 때의 흐름이 아예 다름

이걸 기존의 추상 클래스 방식으로 다룰 거냐, 아니면 인터페이스를 위에 하나 더 둘 거냐의 차이

이처럼 설계에는 여러 방법이 있고, 트레이드 오프가 있다.<br>
이 트레이드 오프를 고려한다는 것은 곧 모든 코드에는 이유가 있다는 것(거기에 있는)

## 상속 vs 합성
상속은
1. 캡슐화를 위반
   부모의 구현을 다 알아야 함.
   부모가 바뀌면 자식도 다 바뀌어야 함.
2. 설계의 유연성을 떨어뜨림
   컴파일 타임에 부모-자식 관계를 지정함.
   자식 A와 자식 B를 서로 갈아끼기 힘듦.

합성은 이 두 가지 문제를 해결함. 

뭐 상속을 아예 쓰지 말라는 건 아니긴 함 -> 상속은 다형성 구현할 때도 쓰이기 때문 -> 근데 꼭 상속만 다형성 구현에 쓰이는 건 또 아님<br>
??? 어쩌래는겨



